{"timestamp":"2025-11-28T13:28:40.736Z","ticketId":"ebfc4eaa-991a-4cbb-8836-22b1d08b354f","patternId":"config-api_endpoint-/api/knowledge/chat","instructionCount":1,"instructions":[{"type":"create-file","file":"app/api/api/knowledge/chat/route.ts","content":"import { NextRequest, NextResponse } from 'next/server';\nimport { createRouteHandlerClient } from '@/lib/supabase';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const { message, sessionId, sourceIds } = await request.json();\n\n    if (!message || !sessionId) {\n      return NextResponse.json(\n        { error: 'Nachricht und Session ID sind erforderlich' },\n        { status: 400 }\n      );\n    }\n\n    const supabase = await createRouteHandlerClient();\n\n    // Get or create chat session\n    let { data: chatSession } = await supabase\n      .from('chat_sessions')\n      .select('id')\n      .eq('session_id', sessionId)\n      .single();\n\n    if (!chatSession) {\n      const { data: newSession, error: sessionError } = await supabase\n        .from('chat_sessions')\n        .insert({\n          session_id: sessionId,\n          knowledge_source_ids: sourceIds || [],\n        })\n        .select()\n        .single();\n\n      if (sessionError) throw sessionError;\n      chatSession = newSession;\n    }\n\n    // Save user message\n    if (chatSession) {\n      await supabase.from('chat_messages').insert({\n        chat_session_id: chatSession.id,\n        role: 'user',\n        content: message,\n      });\n    }\n\n    // Generate query embedding\n    const embeddingResponse = await fetch(\n      (process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000') + '/api/knowledge/embeddings',\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ text: message }),\n      }\n    );\n\n    if (!embeddingResponse.ok) {\n      throw new Error('Embedding-Generierung fehlgeschlagen');\n    }\n\n    const { embedding: queryEmbedding } = await embeddingResponse.json();\n\n    // Search for relevant chunks\n    let query = supabase\n      .from('document_chunks')\n      .select('content, knowledge_source_id, metadata')\n      .not('embedding', 'is', null)\n      .limit(5);\n\n    if (sourceIds && sourceIds.length > 0) {\n      query = query.in('knowledge_source_id', sourceIds);\n    }\n\n    const { data: chunks, error: chunksError } = await query;\n\n    if (chunksError) {\n      console.error('[Chat] Error searching chunks:', chunksError);\n    }\n\n    // Build context from chunks\n    const context = chunks && chunks.length > 0\n      ? chunks.map((c: any) => c.content).join('\\n\\n')\n      : 'Keine relevanten Informationen gefunden.';\n\n    // Generate response (simplified - in production, use OpenAI or similar)\n    const response = 'Basierend auf den bereitgestellten Informationen: ' + context.substring(0, 1000) + '...';\n\n    // Save assistant message\n    if (chatSession) {\n      await supabase.from('chat_messages').insert({\n        chat_session_id: chatSession.id,\n        role: 'assistant',\n        content: response,\n      });\n    }\n\n    return NextResponse.json({\n      response,\n      chunksUsed: chunks?.length || 0,\n    });\n  } catch (error: any) {\n    console.error('[Chat] Error:', error);\n    return NextResponse.json(\n      { error: error.message || 'Chat-Anfrage fehlgeschlagen' },\n      { status: 500 }\n    );\n  }\n}\n","description":"Erstelle fehlende API-Route /api/knowledge/chat basierend auf Reverse Engineering Dokumentation"}]}
